<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <!-- Core engine -->
    <script src="p5.js"></script>

  </head>

  <body>
    <main></main>

    <!-- p5 entry point -->
    <script>
        class Inventory extends GUI {
    constructor(items, x, y, font, w, h) {
        super(x, y, w, h);

        this.items = items;   // array of ItemStack or null
        this.font = font;

        this.cols = 5;
        this.rows = ceil(items.length / this.cols);

        this.slotSize = 50;
        this.padding = 6;
    }

    drawSlot(x, y, stack) {
        // slot background
        fill(60, 60, 60, 200);
        stroke(255);
        rect(x, y, this.slotSize, this.slotSize, 4);

        if (!stack) return;

        // ---------------------------
        // Draw item name
        // ---------------------------
        this.font.drawText(
            stack.item.name,
            x + 5,
            y + this.slotSize / 2
        );

        // ---------------------------
        // Draw quantity (bottom-right)
        // ---------------------------
        if (stack.amount > 1) {
            push();
            fill(255);
            textSize(14);
            textAlign(RIGHT, BOTTOM);
            text(stack.amount, x + this.slotSize - 4, y + this.slotSize - 4);
            pop();
        }
    }

    draw() {
        if (!this.visible) return;

        push();
        translate(this.x, this.y);

        let index = 0;

        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {

                let sx = c * (this.slotSize + this.padding);
                let sy = r * (this.slotSize + this.padding);

                let stack = this.items[index] || null;
                this.drawSlot(sx, sy, stack);

                index++;
            }
        }

        pop();
    }
}
Inventory.prototype.countItem = function(id) {
    let total = 0;
    for (let stack of this.items) {
        if (stack && stack.item.id === id) {
            total += stack.amount;
        }
    }
    return total;
};

Inventory.prototype.removeItems = function(id, amount) {
    for (let stack of this.items) {
        if (!stack) continue;

        if (stack.item.id === id) {
            let take = min(stack.amount, amount);
            stack.amount -= take;
            amount -= take;

            if (stack.amount <= 0) {
                stack.amount = 0;
            }

            if (amount <= 0) return;
        }
    }
};

class Debug extends GUI {
    constructor(font, x, y) {
        super(x, y);
        this.font = font;
        this.lines = [];
    }

    log(text) {
        this.lines.push(text);
        if (this.lines.length > 12) this.lines.shift();
    }

    draw() {
        if (!this.visible) return;

        push();
        fill(0, 150);
        noStroke();
        rect(this.x, this.y, 250, this.lines.length * 20 + 10, 5);

        let offset = 20;
        for (let line of this.lines) {
            this.font.drawText(line, this.x + 10, this.y + offset);
            offset += 20;
        }
        pop();
    }
}

class Font extends GUI {
    constructor(fontpath) {
        super();
        this.font = loadFont(fontpath);
        this.size = 16;
        this.color = color(255);
    }

    setSize(s) { this.size = s; }
    setColor(c){ this.color = c; }

    drawText(text1, x, y) {
        push();
        fill(this.color);
        textFont(this.font);
        textSize(this.size);
        text(text1, x, y);
        pop();
    }
}

// ---------------------------
// Base GUI Class
// ---------------------------
class GUI {
    constructor(x = 0, y = 0, w = 0, h = 0) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;

        this.visible = true;
    }

    show()  { this.visible = true; }
    hide()  { this.visible = false; }
    toggle(){ this.visible = !this.visible; }

    draw() {} // override in subclasses
}
// ---------------------------
// Item Class + Helpers
// ---------------------------

class Item {
    constructor(id, name, icon = null, data = {}) {
        this.id = id;       // unique string: "wood", "stone", "iron"
        this.name = name;   // display name
        this.icon = icon;   // optional image
        this.data = data;   // custom metadata (durability, stats, etc.)
    }

    clone() {
        return new Item(
            this.id,
            this.name,
            this.icon,
            structuredClone(this.data)
        );
    }
}

// ---------------------------
// ItemStack (item + quantity)
// ---------------------------
class ItemStack {
    constructor(item, amount = 1) {
        this.item = item;       // Item object
        this.amount = amount;   // integer
    }

    add(n) { this.amount += n; }
    remove(n) { this.amount = max(0, this.amount - n); }

    isEmpty() { return this.amount <= 0; }

    clone() {
        return new ItemStack(this.item.clone(), this.amount);
    }
}

// ---------------------------
// Item Registry (global)
// ---------------------------
class ItemRegistry {
    constructor() {
        this.items = {};
    }

    register(id, name, icon = null, data = {}) {
        this.items[id] = new Item(id, name, icon, data);
    }

    get(id) {
        if (!this.items[id]) {
            console.warn("Item not found:", id);
            return null;
        }
        return this.items[id].clone();
    }
}

// global registry instance
const ITEMS = new ItemRegistry();
// ---------------------------
// Crafting System
// ---------------------------

class Recipe {
    constructor(inputs, output) {
       // inputs: { "wood": 2, "stone": 1 }
        // output: ItemStack
        this.inputs = inputs;
        this.output = output;
    }

    // Check if inventory contains required items
    canCraft(inventory) {
        for (let id in this.inputs) {
            let needed = this.inputs[id];
            let count = inventory.countItem(id);

            if (count < needed) return false;
        }
        return true;
    }

    // Remove ingredients + return crafted item
    craft(inventory) {
        if (!this.canCraft(inventory)) return null;

        // consume ingredients
        for (let id in this.inputs) {
            let needed = this.inputs[id];
            inventory.removeItems(id, needed);
        }

        return this.output.clone();
    }
}

// ---------------------------
// Crafting Manager
// ---------------------------
class CraftingManager {
    constructor() {
        this.recipes = [];
    }

    addRecipe(inputs, output) {
        this.recipes.push(new Recipe(inputs, output));
    }

    // Try to craft by recipe index
    craftByIndex(index, inventory) {
        if (!this.recipes[index]) return null;
        return this.recipes[index].craft(inventory);
    }

    // Try to craft by matching ingredients
    craftMatching(inventory) {
        for (let recipe of this.recipes) {
            if (recipe.canCraft(inventory)) {
                return recipe.craft(inventory);
            }
        }
        return null;
    }
}

// global crafting manager
const CRAFTING = new CraftingManager();
// ---------------------------
// Terrain Class with Biomes
// ---------------------------
class Terrain {
  constructor(w, h, scl) {
    this.w = w;
    this.h = h;
    this.scl = scl;

    this.cols = floor(w / scl);
    this.rows = floor(h / scl);

    // heightmap
    this.grid = Array.from({ length: this.cols }, () =>
      Array(this.rows).fill(0)
    );

    // biome map (stores color per vertex)
    this.biomes = Array.from({ length: this.cols }, () =>
      Array(this.rows).fill(color(0))
    );
  }

  // ---------------------------
  // Height + Biome Generation
  // ---------------------------
  update() {
    let yoff = 0; // âœ… FIX: no movement

    for (let y = 0; y < this.rows; y++) {
      let xoff = 0;

      for (let x = 0; x < this.cols; x++) {
        // Perlin noise height
        let n = noise(xoff, yoff);
        let heightVal = map(n, 0, 1, -150, 150);

        // jagged quantization
        let jagged = round(heightVal / 10) * 10;
        this.grid[x][y] = jagged;

        // assign biome color
        this.biomes[x][y] = this.getBiomeColor(jagged, n);

        xoff += 0.12;
      }
      yoff += 0.12;
    }
  }

  // ---------------------------
  // Biome Logic
  // ---------------------------
  getBiomeColor(height, noiseVal) {
    if (height < -80) {
      return color(0, 0, 150); // deep water
    }
    if (height < -20) {
      return color(0, 80, 200); // shallow water
    }
    if (height < 10) {
      return color(194, 178, 128); // beach
    }
    if (height < 60) {
      return color(34, 139, 34); // grassland
    }
    if (height < 110) {
      return color(139, 69, 19); // rocky
    }
    return color(240); // snow
  }

  // ---------------------------
  // Render Terrain Mesh
  // ---------------------------
  render() {
    for (let y = 0; y < this.rows - 1; y++) {
      beginShape(TRIANGLE_STRIP);

      for (let x = 0; x < this.cols; x++) {
        let xPos = x * this.scl;
        let yPos = y * this.scl;

        let c1 = this.biomes[x][y];
        let c2 = this.biomes[x][y + 1];

        // darker stroke color
        let s1 = color(
          red(c1) * 0.7,
          green(c1) * 0.7,
          blue(c1) * 0.7
        );

        strokeWeight(1.5);
        stroke(s1);

        // upper vertex
        fill(c1);
        vertex(xPos, this.grid[x][y], yPos);

        // lower vertex
        fill(c2);
        vertex(xPos, this.grid[x][y + 1], yPos + this.scl);
      }

      endShape();
    }
  }
}
class Player {
  constructor(x, y, z) {
    this.pos = createVector(x, y, z);
    this.vel = createVector(0, 0, 0);

    this.speed = 4;
    this.jumpForce = 12;
    this.gravity = 0.7;

    this.radius = 20; // player collision size
  }

  // ---------------------------
  // Movement Input
  // ---------------------------
  handleInput() {
    let forward = createVector(0, 0, -1);
    let right = createVector(1, 0, 0);

    // WASD movement
    if (keyIsDown(87)) this.pos.add(p5.Vector.mult(forward, this.speed)); // W
    if (keyIsDown(83)) this.pos.add(p5.Vector.mult(forward, -this.speed)); // S
    if (keyIsDown(65)) this.pos.add(p5.Vector.mult(right, -this.speed)); // A
    if (keyIsDown(68)) this.pos.add(p5.Vector.mult(right, this.speed)); // D
  }

  // ---------------------------
  // Physics + Gravity
  // ---------------------------
  applyPhysics(terrain) {
    // gravity
    this.vel.y += this.gravity;
    this.pos.add(this.vel);

    // terrain collision
    let groundY = this.getTerrainHeight(terrain);

    if (this.pos.y > groundY - this.radius) {
      this.pos.y = groundY - this.radius;
      this.vel.y = 0;
    }
  }

  // ---------------------------
  // Jump
  // ---------------------------
  jump() {
    if (this.vel.y === 0) {
      this.vel.y = -this.jumpForce;
    }
  }

  // ---------------------------
  // Sample Terrain Height
  // ---------------------------
  getTerrainHeight(terrain) {
    let tx = floor(this.pos.x / terrain.scl);
    let tz = floor(this.pos.z / terrain.scl);

    tx = constrain(tx, 0, terrain.cols - 1);
    tz = constrain(tz, 0, terrain.rows - 1);

    return terrain.grid[tx][tz];
  }

  // ---------------------------
  // Render Player
  // ---------------------------
  render() {
    push();
    translate(this.pos.x, this.pos.y, this.pos.z);
    fill(255, 200, 0);
    noStroke();
    sphere(this.radius);
    pop();
  }
}
class FirstPersonCamera {
  constructor(x, y, z, fov, toFollow) {
    this.pos = createVector(x, y, z);
    this.fov = fov;
    this.target = toFollow; // player or any object with .pos

    this.yaw = 0;   // left/right rotation
    this.pitch = 0; // up/down rotation

    this.sensitivity = 0.2;
  }

  // ---------------------------
  // Mouse Look
  // ---------------------------
  handleMouseLook() {
    let dx = movedX * this.sensitivity;
    let dy = movedY * this.sensitivity;

    this.yaw   -= dx;
    this.pitch -= dy;

    // clamp pitch so camera doesn't flip
    this.pitch = constrain(this.pitch, -89, 89);
  }

  // ---------------------------
  // Follow Target (Player)
  // ---------------------------
  followTarget() {
    if (!this.target) return;

    // camera sits at player's head height
    this.pos.x = this.target.pos.x;
    this.pos.y = this.target.pos.y - 20;
    this.pos.z = this.target.pos.z;
  }

  // ---------------------------
  // Apply Camera Transform
  // ---------------------------
  apply() {
    // convert yaw/pitch to a forward direction vector
    let dir = createVector(
      cos(this.pitch) * sin(this.yaw),
      sin(this.pitch),
      cos(this.pitch) * cos(this.yaw)
    );

    // set FOV
    perspective(this.fov, width / height, 0.1, 5000);

    // apply camera
    camera(
      this.pos.x, this.pos.y, this.pos.z,
      this.pos.x + dir.x,
      this.pos.y + dir.y,
      this.pos.z + dir.z,
      0, 1, 0
    );
  }

  // ---------------------------
  // Update Camera Each Frame
  // ---------------------------
  update() {
    this.handleMouseLook();
    this.followTarget();
    this.apply();
  }
}
// ---------------------------
// GAME CLASS
// ---------------------------
class Game {
    constructor() {
        this.terrain = null;
        this.player = null;
        this.camera = null;

        this.inventory = null;
        this.debug = null;
        this.font = null;

        this.lastFrame = 0;
    }

    // ---------------------------
    // LOAD ASSETS
    // ---------------------------
    preload() {
        this.font = new Font("/Minecraft.ttf");
    }

    // ---------------------------
    // INITIALIZE GAME SYSTEMS
    // ---------------------------
    setup() {
        createCanvas(1280, 720, WEBGL);
        angleMode(DEGREES);

        // --- Items ---
        registerDefaultItems();

        // --- Crafting Recipes ---
        CRAFTING.addRecipe(
            { "wood": 1, "stone": 1 },
            stack("torch", 2)
        );

        CRAFTING.addRecipe(
            { "stone": 3, "wood": 2 },
            stack("pickaxe", 1)
        );

        // --- Terrain ---
        this.terrain = new Terrain(2000, 2000, 20);
        this.terrain.update();

        // --- Player ---
        this.player = new Player(0, -200, 0);

        // --- Camera ---
        this.camera = new FirstPersonCamera(0, -200, 0, 60, this.player);

        // --- Inventory ---
        this.inventory = new Inventory(
            [
                stack("wood", 5),
                stack("stone", 3),
                stack("apple", 1),
                null,
                null,
                null
            ],
            20, 20, this.font, 300, 300
        );

        // --- Debug Panel ---
        this.debug = new Debug(this.font, 20, 350);

        // Lock mouse for FPS camera
        
    }


    // ---------------------------
    // UPDATE GAME LOGIC
    // ---------------------------
    update(dt) {
        this.player.handleInput();
        this.player.applyPhysics(this.terrain);

        this.camera.update();

        // Debug info
        this.debug.lines = [];
        this.debug.log("FPS: " + floor(frameRate()));
        this.debug.log("Player X: " + floor(this.player.pos.x));
        this.debug.log("Player Y: " + floor(this.player.pos.y));
        this.debug.log("Player Z: " + floor(this.player.pos.z));
    }

    // ---------------------------
    // RENDER EVERYTHING
    // ---------------------------
    render() {
        background(135, 206, 235);

        // World
        push();
        rotateX(60);
        translate(-this.terrain.w / 2, -200, -this.terrain.h / 2);
        this.terrain.render();
        pop();

        // UI
        this.inventory.draw();
        this.debug.draw();
    }

    // ---------------------------
    // MAIN GAME LOOP
    // ---------------------------
    loop() {
        let now = millis();
        let dt = (now - this.lastFrame) / 1000;
        this.lastFrame = now;

        this.update(dt);
        this.render();
    }
}

// ---------------------------
// GLOBAL GAME INSTANCE
// ---------------------------
let game = new Game();

// p5.js hooks
function preload() { game.preload(); }
function setup() { game.setup(); }
function draw() { game.loop(); }
document.addEventListener("click", () => {
  canvas.requestPointerLock();
});
// ---------------------------
// INPUT HANDLING
// ---------------------------
function keyPressed() {
    if (key === ' ') {
        game.player.jump();
    }
    if (key === 'i') {
        game.inventory.toggle();
    }
    if (key === 'c') {
        let result = CRAFTING.craftMatching(game.inventory);
        if (result) {
            game.inventory.items.push(result);
        }
    }
}

    </script>
  </body>
</html>
